<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Реалистичная сцена с BMW M5 F90 и физикой столкновений</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    
    .instructions {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      z-index: 1;
    }

    /* Реалистичный спидометр */
    #speedometer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      border: 2px solid #fff;
      box-sizing: border-box;
      z-index: 1;
    }

    /* Стрелка спидометра */
    #needle {
      position: absolute;
      bottom: 100px;
      right: 100px;
      width: 2px;
      height: 90px;
      background: red;
      transform-origin: bottom center;
      transform: rotate(0deg);
      transition: transform 0.1s linear;
    }

    /* Фон циферблата */
    #speedometer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 200px;
      height: 200px;
      background: url('https://i.imgur.com/6R9tKcP.png') no-repeat center center; /* Замените на свой URL изображения циферблата */
      background-size: cover;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="instructions">
    WASD - движение<br>
    F - сесть/выйти из машины<br>
    Мышь - осмотреться
  </div>

  <!-- Спидометр -->
  <div id="speedometer">
    <div id="needle"></div>
  </div>
  
  <!-- Подключаем библиотеки -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  
  <script>
    // Инициализация сцены, камеры и рендерера
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    // Skybox для реалистичного неба
    const loaderSky = new THREE.CubeTextureLoader();
    const skyboxTextures = [
      'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
    ];
    const skybox = loaderSky.load(skyboxTextures);
    scene.background = skybox;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 30);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Добавляем освещение
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);
    
    // Создаем землю
    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Создаем дорогу
    const roadGeometry = new THREE.BoxGeometry(200, 0.1, 20);
    const roadMaterial = new THREE.MeshStandardMaterial({color: 0x555555});
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.position.set(0, 0.05, 0);
    road.receiveShadow = true;
    scene.add(road);
    
    // Функция для создания домов
    function createHouse(x, z) {
      const houseGeometry = new THREE.BoxGeometry(10, 10, 10);
      const houseMaterial = new THREE.MeshStandardMaterial({color: 0x8B4513});
      const house = new THREE.Mesh(houseGeometry, houseMaterial);
      house.position.set(x, 5, z);
      house.castShadow = true;
      house.receiveShadow = true;
      scene.add(house);

      // Добавляем крышу
      const roofGeometry = new THREE.ConeGeometry(7, 4, 4);
      const roofMaterial = new THREE.MeshStandardMaterial({color: 0xFF0000});
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(0, 7, 0);
      roof.rotation.y = Math.PI / 4;
      house.add(roof);
    }

    // Создаем несколько домов
    for(let i = -50; i <= 50; i += 30){
      createHouse(i, -40);
      createHouse(i, 40);
    }

    // Функция для создания деревьев
    function createTree(x, z) {
      // Ствол
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({color: 0x8B4513});
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.set(x, 2.5, z);
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);

      // Крона
      const foliageGeometry = new THREE.SphereGeometry(2.5, 8, 8);
      const foliageMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.set(0, 4, 0);
      foliage.castShadow = true;
      foliage.receiveShadow = true;
      trunk.add(foliage);
    }

    // Создаем несколько деревьев
    for(let i = -80; i <= 80; i += 20){
      createTree(i, -60);
      createTree(i, 60);
      createTree(-60, i);
      createTree(60, i);
    }

    // Функция для создания уличных фонарей
    function createStreetLight(x, z) {
      // Столб
      const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 8);
      const poleMaterial = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
      const pole = new THREE.Mesh(poleGeometry, poleMaterial);
      pole.position.set(x, 5, z);
      pole.castShadow = true;
      pole.receiveShadow = true;
      scene.add(pole);

      // Лампа
      const lampGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const lampMaterial = new THREE.MeshBasicMaterial({color: 0xffffe0});
      const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
      lamp.position.set(0, 5.5, 0);
      pole.add(lamp);
    }

    // Создаем несколько уличных фонарей
    for(let i = -90; i <= 90; i += 30){
      createStreetLight(i, -50);
      createStreetLight(i, 50);
      createStreetLight(-50, i);
      createStreetLight(50, i);
    }

    // Инициализация физического мира
    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0); // Гравитация

    // Создание физического тела для земли
    const groundBody = new CANNON.Body({
      mass: 0, // Статическое тело
      shape: new CANNON.Plane(),
      material: new CANNON.Material({ friction: 0.5, restitution: 0.7 })
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // Функция для создания физического тела коробки
    function createBoxBody(width, height, depth, mass, position) {
      const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
      const body = new CANNON.Body({ mass: mass, shape: shape });
      body.position.set(position.x, position.y, position.z);
      world.addBody(body);
      return body;
    }

    // Спидометр
    const speedometer = document.getElementById('speedometer');
    const needle = document.getElementById('needle');
    
    function updateSpeedometer(currentSpeed) {
      // Ограничение скорости
      currentSpeed = Math.min(currentSpeed, 200);
      
      // Расчет угла стрелки (от -135 до 135 градусов)
      const minAngle = -135;
      const maxAngle = 135;
      const speedRatio = currentSpeed / 200;
      const angle = minAngle + speedRatio * (maxAngle - minAngle);
      
      needle.style.transform = `rotate(${angle}deg)`;
    }

    // Загрузка 3D модели автомобиля (замените на модель BMW M5 F90)
    const loader = new THREE.GLTFLoader();
    let car, carBody;
    loader.load(
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb', // Замените на URL вашей модели BMW M5 F90
      function(gltf){
        car = gltf.scene;
        car.scale.set(0.5, 0.5, 0.5); // Настройка масштаба
        car.position.set(0, 0, 0);
        car.traverse(function(node){
          if(node.isMesh){
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        scene.add(car);

        // Создание физического тела для автомобиля
        const box = new CANNON.Box(new CANNON.Vec3(2, 1, 4)); // Размеры коробки
        carBody = new CANNON.Body({ mass: 1500 }); // Масса автомобиля
        carBody.addShape(box);
        carBody.position.set(car.position.x, car.position.y, car.position.z);
        carBody.angularDamping = 0.5;
        world.addBody(carBody);
      },
      undefined,
      function(error){
        console.error('Ошибка загрузки модели автомобиля:', error);
        // Если модель не загрузилась, используем простую геометрию
        const carGeometry = new THREE.BoxGeometry(4, 2, 8);
        const carMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
        car = new THREE.Mesh(carGeometry, carMaterial);
        car.position.y = 1;
        car.castShadow = true;
        car.receiveShadow = true;
        scene.add(car);

        // Создание физического тела для автомобиля
        const box = new CANNON.Box(new CANNON.Vec3(2, 1, 4)); // Размеры коробки
        carBody = new CANNON.Body({ mass: 1500 }); // Масса автомобиля
        carBody.addShape(box);
        carBody.position.set(car.position.x, car.position.y, car.position.z);
        carBody.angularDamping = 0.5;
        world.addBody(carBody);
      }
    );

    // Загрузка 3D модели игрока
    let player, playerBody;
    loader.load(
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Flamingo/glTF-Binary/Flamingo.glb', // Можно заменить на другую модель
      function(gltf){
        player = gltf.scene;
        player.scale.set(0.02, 0.02, 0.02); // Настройка масштаба
        player.position.set(5, 0, 0);
        player.traverse(function(node){
          if(node.isMesh){
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        scene.add(player);

        // Создание физического тела для игрока
        const sphere = new CANNON.Sphere(1); // Радиус сферы
        playerBody = new CANNON.Body({ mass: 70 }); // Масса человека
        playerBody.addShape(sphere);
        playerBody.position.set(player.position.x, player.position.y, player.position.z);
        playerBody.angularDamping = 0.5;
        world.addBody(playerBody);
      },
      undefined,
      function(error){
        console.error('Ошибка загрузки модели игрока:', error);
        // Если модель не загрузилась, используем простую геометрию
        const playerGeometry = new THREE.BoxGeometry(1, 3.6, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({color: 0x0000ff});
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(5, 1.8, 0);
        player.castShadow = true;
        player.receiveShadow = true;
        scene.add(player);

        // Создание физического тела для игрока
        const box = new CANNON.Box(new CANNON.Vec3(0.5, 1.8, 0.5)); // Размеры коробки
        playerBody = new CANNON.Body({ mass: 70 }); // Масса человека
        playerBody.addShape(box);
        playerBody.position.set(player.position.x, player.position.y, player.position.z);
        playerBody.angularDamping = 0.5;
        world.addBody(playerBody);
      }
    );

    // Состояния игры
    let inCar = false;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let rotation = 0;
    let speed = 0;
    const maxSpeed = 200; // Максимальная скорость км/ч
    const acceleration = 2; // Ускорение км/ч за кадр
    const deceleration = 1; // Замедление км/ч за кадр

    // Обработчики клавиш
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'KeyF':
          if(car && player && player.visible && player.position.distanceTo(car.position) < 5) {
            inCar = !inCar;
            if(inCar) {
              player.visible = false;
            } else {
              player.visible = true;
              player.position.set(
                car.position.x + 3 * Math.sin(rotation),
                1,
                car.position.z + 3 * Math.cos(rotation)
              );
              playerBody.position.set(
                car.position.x + 3 * Math.sin(rotation),
                1,
                car.position.z + 3 * Math.cos(rotation)
              );
              playerBody.velocity.set(0, 0, 0); // Сброс скорости при выходе
            }
          }
          break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch(event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
    });

    // Управление мышью
    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === renderer.domElement) {
        rotation -= event.movementX * 0.002;
      }
    });

    // Блокировка указателя мыши
    renderer.domElement.addEventListener('click', () => {
      renderer.domElement.requestPointerLock();
    });

    // Функция обновления физического мира
    function updatePhysics(delta) {
      world.step(delta);
      
      if(car && carBody) {
        // Обновляем позицию и ориентацию автомобиля
        car.position.copy(carBody.position);
        car.quaternion.copy(carBody.quaternion);
      }

      if(player && playerBody && !inCar) {
        // Обновляем позицию и ориентацию игрока
        player.position.copy(playerBody.position);
        player.quaternion.copy(playerBody.quaternion);
      }
    }

    // Функция анимации
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      updatePhysics(delta);

      if(car && inCar) {
        // Управление автомобилем
        if(moveForward) {
          speed += acceleration;
        }
        if(moveBackward) {
          speed -= acceleration;
        }
        if(!moveForward && !moveBackward) {
          // Естественное замедление
          if(speed > 0) {
            speed -= deceleration;
            speed = Math.max(speed, 0);
          } else {
            speed += deceleration;
            speed = Math.min(speed, 0);
          }
        }
        if(moveLeft) rotation += 0.02;
        if(moveRight) rotation -= 0.02;
    
        // Ограничение скорости
        speed = Math.max(-maxSpeed, Math.min(speed, maxSpeed));
    
        // Обновление физического тела автомобиля
        carBody.angularVelocity.set(0, rotation * 5, 0);
        carBody.velocity.x = Math.sin(rotation) * speed * 0.05;
        carBody.velocity.z = Math.cos(rotation) * speed * 0.05;
    
        // Обновление спидометра
        updateSpeedometer(Math.abs(speed));
      } else if(player && !inCar) {
        // Управление игроком
        if(moveForward) {
          playerBody.velocity.x += Math.sin(rotation) * 0.5;
          playerBody.velocity.z += Math.cos(rotation) * 0.5;
        }
        if(moveBackward) {
          playerBody.velocity.x -= Math.sin(rotation) * 0.5;
          playerBody.velocity.z -= Math.cos(rotation) * 0.5;
        }
        if(moveLeft) rotation += 0.02;
        if(moveRight) rotation -= 0.02;
    
        // Обновление спидометра
        updateSpeedometer(0);
      }
      
      renderer.render(scene, camera);
    }
    
    animate();

    // Обработка изменения размера окна
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
