<!DOCTYPE html>
<html>
<head>
  <base href="." />
  <meta charset="UTF-8">
  <title>Реалистичная сцена с BMW M5 F90</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    
    .instructions {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      z-index: 1;
    }

    /* Реалистичный спидометр */
    #speedometer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      border: 2px solid #fff;
      box-sizing: border-box;
      z-index: 1;
    }

    /* Стрелка спидометра */
    #needle {
      position: absolute;
      bottom: 100px;
      right: 100px;
      width: 2px;
      height: 90px;
      background: red;
      transform-origin: bottom center;
      transform: rotate(0deg);
      transition: transform 0.1s linear;
    }

    /* Фон циферблата */
    #speedometer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 200px;
      height: 200px;
      background: url('https://i.imgur.com/6R9tKcP.png') no-repeat center center; /* Замените на свой URL изображения циферблата */
      background-size: cover;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="instructions">
    WASD - движение<br>
    F - сесть/выйти из машины<br>
    Мышь - осмотреться
  </div>

  <!-- Спидометр -->
  <div id="speedometer">
    <div id="needle"></div>
  </div>
  
  <!-- Подключаем three.js и GLTFLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Создаем сцену, камеру и рендерер
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    // Добавляем Skybox
    const loaderSky = new THREE.CubeTextureLoader();
    const skyboxTextures = [
      'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
      'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
    ];
    const skybox = loaderSky.load(skyboxTextures);
    scene.background = skybox;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 30);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Добавляем управление камерой (для отладки, можно удалить в финальной версии)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;

    // Добавляем освещение
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);
    
    // Создаем землю
    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Создаем дорогу
    const roadGeometry = new THREE.BoxGeometry(200, 0.1, 20);
    const roadMaterial = new THREE.MeshStandardMaterial({color: 0x555555});
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.position.set(0, 0.05, 0);
    road.receiveShadow = true;
    scene.add(road);
    
    // Функция для создания домов
    function createHouse(x, z) {
      const houseGeometry = new THREE.BoxGeometry(10, 10, 10);
      const houseMaterial = new THREE.MeshStandardMaterial({color: 0x8B4513});
      const house = new THREE.Mesh(houseGeometry, houseMaterial);
      house.position.set(x, 5, z);
      house.castShadow = true;
      house.receiveShadow = true;
      scene.add(house);

      // Добавляем крышу
      const roofGeometry = new THREE.ConeGeometry(7, 4, 4);
      const roofMaterial = new THREE.MeshStandardMaterial({color: 0xFF0000});
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(0, 7, 0);
      roof.rotation.y = Math.PI / 4;
      house.add(roof);
    }

    // Создаем несколько домов
    for(let i = -50; i <= 50; i += 30){
      createHouse(i, -40);
      createHouse(i, 40);
    }

    // Функция для создания деревьев
    function createTree(x, z) {
      // Ствол
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({color: 0x8B4513});
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.set(x, 2.5, z);
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);

      // Крона
      const foliageGeometry = new THREE.SphereGeometry(2.5, 8, 8);
      const foliageMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.set(0, 4, 0);
      foliage.castShadow = true;
      foliage.receiveShadow = true;
      trunk.add(foliage);
    }

    // Создаем несколько деревьев
    for(let i = -80; i <= 80; i += 20){
      createTree(i, -60);
      createTree(i, 60);
      createTree(-60, i);
      createTree(60, i);
    }

    // Функция для создания уличных фонарей
    function createStreetLight(x, z) {
      // Столб
      const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 8);
      const poleMaterial = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
      const pole = new THREE.Mesh(poleGeometry, poleMaterial);
      pole.position.set(x, 5, z);
      pole.castShadow = true;
      pole.receiveShadow = true;
      scene.add(pole);

      // Лампа
      const lampGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const lampMaterial = new THREE.MeshBasicMaterial({color: 0xffffe0});
      const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
      lamp.position.set(0, 5.5, 0);
      pole.add(lamp);
    }

    // Создаем несколько уличных фонарей
    for(let i = -90; i <= 90; i += 30){
      createStreetLight(i, -50);
      createStreetLight(i, 50);
      createStreetLight(-50, i);
      createStreetLight(50, i);
    }

    // Загрузка 3D модели автомобиля (BMW M5 F90)
    const loader = new THREE.GLTFLoader();
    let car;
    loader.load(
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb', // Замените на URL вашей модели BMW M5 F90
      function(gltf){
        car = gltf.scene;
        car.scale.set(0.5, 0.5, 0.5); // Настройка масштаба
        car.position.set(0, 0, 0);
        car.traverse(function(node){
          if(node.isMesh){
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        scene.add(car);
      },
      undefined,
      function(error){
        console.error('Ошибка загрузки модели автомобиля:', error);
        // Если модель не загрузилась, используем простую геометрию
        const carGeometry = new THREE.BoxGeometry(2, 1, 4);
        const carMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
        car = new THREE.Mesh(carGeometry, carMaterial);
        car.position.y = 0.5;
        car.castShadow = true;
        car.receiveShadow = true;
        scene.add(car);
      }
    );
    
    // Загрузка 3D модели игрока
    let player;
    loader.load(
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Flamingo/glTF-Binary/Flamingo.glb', // Можно заменить на другую модель
      function(gltf){
        player = gltf.scene;
        player.scale.set(0.02, 0.02, 0.02); // Настройка масштаба
        player.position.set(5, 0, 0);
        player.traverse(function(node){
          if(node.isMesh){
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        scene.add(player);
      },
      undefined,
      function(error){
        console.error('Ошибка загрузки модели игрока:', error);
        // Если модель не загрузилась, используем простую геометрию
        const playerGeometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
        const playerMaterial = new THREE.MeshStandardMaterial({color: 0x0000ff});
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(5, 0.9, 0);
        player.castShadow = true;
        player.receiveShadow = true;
        scene.add(player);
      }
    );
    
    // Состояния игры
    let inCar = false;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let rotation = 0;
    let speed = 0;
    const maxSpeed = 200; // Максимальная скорость км/ч
    const acceleration = 2; // Ускорение км/ч за кадр
    const deceleration = 1; // Замедление км/ч за кадр

    // Обработчики клавиш
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'KeyF':
          if(car && player && player.visible && player.position.distanceTo(car.position) < 5) {
            inCar = !inCar;
            if(inCar) {
              player.visible = false;
            } else {
              player.visible = true;
              player.position.set(
                car.position.x + 3 * Math.sin(rotation),
                0.5,
                car.position.z + 3 * Math.cos(rotation)
              );
            }
          }
          break;
      }
    });
    
    document.addEventListener('keyup', (event) => {
      switch(event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
    });
    
    // Управление мышью
    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === renderer.domElement) {
        rotation -= event.movementX * 0.002;
      }
    });
    
    // Блокировка указателя мыши
    renderer.domElement.addEventListener('click', () => {
      renderer.domElement.requestPointerLock();
    });
    
    // Настройка спидометра
    const speedometer = document.getElementById('speedometer');
    const needle = document.getElementById('needle');
    
    function updateSpeedometer(currentSpeed) {
      // Ограничение скорости
      currentSpeed = Math.min(currentSpeed, maxSpeed);
      
      // Расчет угла стрелки (например, от -135 градусов до 135 градусов)
      const minAngle = -135;
      const maxAngle = 135;
      const speedRatio = currentSpeed / maxSpeed;
      const angle = minAngle + speedRatio * (maxAngle - minAngle);
      
      needle.style.transform = `rotate(${angle}deg)`;
    }
    
    // Функция анимации
    function animate() {
      requestAnimationFrame(animate);
      
      // Обновляем управление камерой только если не используем OrbitControls
      // controls.update(); // Можно закомментировать, если не используется для финальной версии

      if(car && inCar) {
        // Управление автомобилем
        if(moveForward) {
          speed += acceleration;
        }
        if(moveBackward) {
          speed -= acceleration;
        }
        if(!moveForward && !moveBackward) {
          // Естественное замедление
          if(speed > 0) {
            speed -= deceleration;
            speed = Math.max(speed, 0);
          } else {
            speed += deceleration;
            speed = Math.min(speed, 0);
          }
        }
        if(moveLeft) rotation += 0.02;
        if(moveRight) rotation -= 0.02;
    
        // Ограничение скорости
        speed = Math.max(-maxSpeed, Math.min(speed, maxSpeed));
    
        // Обновление позиции машины
        car.rotation.y = rotation;
        const velocity = speed * 0.05; // Коэффициент для масштабирования скорости
        car.position.x += Math.sin(rotation) * velocity;
        car.position.z += Math.cos(rotation) * velocity;
        
        // Камера следует за машиной
        camera.position.x = car.position.x - Math.sin(rotation) * 30;
        camera.position.z = car.position.z - Math.cos(rotation) * 30;
        camera.position.y = car.position.y + 15;
        camera.lookAt(car.position);
        
        // Обновление спидометра
        updateSpeedometer(Math.abs(speed));
      } else if(player) {
        // Управление игроком
        if(moveForward) {
          player.position.x += Math.sin(rotation) * 0.1;
          player.position.z += Math.cos(rotation) * 0.1;
        }
        if(moveBackward) {
          player.position.x -= Math.sin(rotation) * 0.1;
          player.position.z -= Math.cos(rotation) * 0.1;
        }
        if(moveLeft) rotation += 0.02;
        if(moveRight) rotation -= 0.02;
    
        player.rotation.y = rotation;
        
        // Камера следует за игроком
        camera.position.x = player.position.x - Math.sin(rotation) * 10;
        camera.position.z = player.position.z - Math.cos(rotation) * 10;
        camera.position.y = player.position.y + 10;
        camera.lookAt(player.position);
        
        // Спидометр показывает 0
        updateSpeedometer(0);
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Обработка изменения размера окна
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
